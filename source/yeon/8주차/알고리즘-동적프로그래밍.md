# 동적 프로그래밍 (Dynamic Programming)



### 동적 프로그래밍 (Dynamic Programming)

다른 알고리즘들과는 다르게 동적 프로그래밍은 용어 자체와는 뜻이 불일치 하는 알고리즘이다. <br>

먼저 프로그래밍이란, 컴퓨터 언어로 코딩을 하는 것이 아니라 계획을 세우는 것을 의미하는 바가 크다. <br>

즉, 어떠한 문제가 주어졌을 때 문제를 특수한 형태로 변형시켜 쉽게 풀려는 과정이다. 하지만 위에서 말했듯이 동적이거나 다이나믹과는 거리가 멀다. <br>

오히려 **기억하는 프로그래밍**이라는 것이 더 맞는 말이다. 흔히 메모이제이션에서 재귀 호출 시 반복되는 값들을 저장하여 계산 횟수를 줄이는 방법은 <br>

바로 동적 프로그래밍 중 하나이다. <br>

이러한 동적 프로그래밍 기법은 코딩 테스트에서의 출제 빈도가 높고, 입문하기 쉽지만 마스터하기는 굉장히 어려운 알고리즘이라고 할 수 있다. <br>



원리는 다음과 같다. <br>

1. 주어진 문제를 여러 개의 하위 문제로 나눈다. 
2. 각 하위 문제의 해결을 계산 한 뒤, 해답을 저장하여 후에 같은 하위 문제가 나왔을 경우 저장한 값을 사용하여 계산 횟수를 줄일 수 있다.
3. 이러한 방법으로 결합하여 최종적인 목적에 도달한다.

DP를 사용하면 부분 문제를 다시 해결하는 시간을 절약할 수 있지만, 이전 계산값을 저장할 공간이 필요하므로 결국 **time - space간의 trade off** 이다. <br>

동적 프로그래밍은 문제를 해결하기 위해 모든 방법을 검토하고, 그 중에 최적의 풀이법을 찾아내기 때문에 최적화에 주로 사용된다. <br>

따라서 DP를 주먹구구식 방법이라고 생각할 수 있지만, 문제가 가능한 모든 방법을 빠른 속도로 처리가 가능한 경우 동적 계획법은 최적의 해법이다. <br>



이러한 주먹구구식 방법이라는 단점을 해결하기 위해 우리가 다뤘던 **그리디 알고리즘**이 등장하게 되었다. <br>

둘을 비교해보자면 **동적 프로그래밍**을 사용하면 약간의 시간이 걸린다는 단점이 있다. 그러나 이렇게 얻어낸 해답은 최적의 답이라고 장담할 수 있다. <br>

반면 그리디 알고리즘은 즉효성이 있는 대신, 항상 최적의 답을 찾아주지는 않는다. 각 구간마다 최적의 경로를 찾는다고 해도 그것이 전체적으로 <br>

최적의 경로가 되지는 않기 때문이다. 즉, 동적 프로그래밍은 그리디 알고리즘에 비해 시간적으로는 효율적이지 못할 수는 있어도, 그 결과에 대해서는 <br>

효율적인 값을 구할 수가 있다.



이번 과제를 하면서 처음에는 어떤식으로 접근을 해야지 dp의 값을 생각할 수 있을까를 많이 고민해봤지만 처음에는 생각이 나지 않았다. <br>

그래서 다른 여러개의 문제들을 풀어보면서 조금씩 dp로 저장해야하는 값들이나 dp의 값이 무엇이 되어야할지 감을 잡아보았다. <br>

추가로 푼 문제들은 다음과 같다. **#1932 정수삼각형, #1149 RGB 거리, #2193 이친수** <br>



### 장점

1. 모든 가능성을 고려하여 답을 찾으므로 항상 최적의 결과를 얻을 수 있다.  <br>



### 단점

1. 모든 가능성에 대한 고려가 불충분할 경우, 최적의 결과를 보장할 수 없다. 또한 다른 알고리즘에 비해 배열을 이용하므로 메모리를 많이 요구한다. <br>



## 동적 프로그래밍 방식

❖ **Memorization** : 한번 계산 된 값을 기록해두고 이후 중복 호출 되었을 때 다시 계산하는 것이 아닌 저장해 둔 값을 가져와 사용하는 것이다. 

![memorization](../images/DPmemorization.png)

아래의 그림과 같이 단순 탐색으로 구현한 경우 fibo(7)을 구하기 위해서는 fibo(2)의 값이 여러번 계산되는 것을 볼 수 있지만 <br>

memorization을 이용해 값을 저장한 경우 계산 횟수가 줄어든 것을 확인할 수 있다. <br>

1. **Top - Down**

   큰 문제에서 작은 부분문제를 **재귀적으로 호출**하여 리턴되는 값을 이용해 큰 문제를 해결한다. 위에서 언급한 그림이 바로 top-down 방식이다. <br>

2. **Bottom - Up**

   작은 부분문제들을 미리 계산해두고, 이 부분문제들을 모아 큰 문제를 해결한다. 일반적으로 배열에 값을 채워나가며 위의 fibonacci를 <br>

   bottom - up 으로 구현하면 다음과 같이 배열에 채워져 나간다. <br>

   Fibo[N] = Fibo[N-2] + Fibo[N-1] 이라고 할 수 있고 F[0], F[1] = 1이다. <br>

   |  0   |  1   |    2    |    3    |    4    | ...  |          N-1          |           N           |
   | :--: | :--: | :-----: | :-----: | :-----: | :--: | :-------------------: | :-------------------: |
   |  1   |  1   | 1+1 = 2 | 1+2 = 3 | 2+3 = 5 |      | Fibo(N-3) + Fibo(N-2) | Fibo(N-2) + Fibo(N-1) |



두 방법은 각각 장단점이 존재한다. <br>

1. **Top-Down** 

   **장점** : 큰 문제를 해결하는데 필요한 sub-problem만 호출해 계산하므로 때때로 bottom-up보다 빠를 수 있다. <br>

   **단점** : 재귀함수로 구현되므로 함수호출에 대한 오버헤드가 발생한다. <br>

2. **Bottom-UP**

   **장점** : 반복문으로 구현되므로 비교적 시간 및 메모리의 최적화가 쉽다. <br>

   **단점** : 큰 문제를 해결하기까지 어떤 sub-problem이 요구되는지 알 수 없으므로 모든 부분문제를 계산해야한다. <br>

   

## 동적 프로그래밍(Dynamic Programming) 알고리즘이 사용되는 예시 

1. 최장 공통 부분 수열 (주어진 두 개 이상의 수열의 부분수열이 되는 가장 긴 수열을 찾는 알고리즘)
2. 피보나치 수열(Fibonacci Sequence)
3. 배낭 문제(Knapsack problem)



### 최장 공통 부분 수열

**최장 공통 부분 수열(LCS)** 문제는 두 개의 문자열에서 순서대로 겹치는 문자가 최대 몇 개인지 구하는 문제이다. <br>

예를 들어, ABCBDAB와 BDCABA에서 LCS는 BDAB, BCAB가 될 수 있다.  <br>

즉 앞에서 부터 겹치는 것들을 찾아서 문자열을 만들 때 그 길이가 가장 길면 LCS라고 할 수 있다. <br>

이 문제는 다음과 같이 분석할 수 있다. 현재 주어진 두 문자열을 X, Y라고 하겠다. 이때 X와 Y 문자열의 마지막 문자열이 같다면 <br>

lcs(i,j) = lcs(i-1,j-1) + 1 이라고 할 수 있다. 왜냐하면 마지막 문자열이 같기 때문에 개수를 세주고 그 앞에 있는 문자열들만 확인하겠다는 것이다. <br>

X와 Y의 마지막 문자열이 다르면 lcs(i,j) = max(lcs(i,j-1), lcs(i-1,j)) 즉 두 개를 마지막에서 하나씩 빼고 비교하여 둘 중에 더 큰 것으로 하겠다는 것이다. <br>

이 방법은 **bottom-up 방식**이라고 할 수 있다.



### 피보나치 수열(Fibonacci Sequence)

피보나치 수열은 위에서 언급하였으므로 넘어가겠다. 



### 0 - 1 배낭 문제(Knapsack problem)

배낭 문제는 무게 제한이 50인 배낭에 다음의 세 개의 물건을 넣는 문제이다. 배낭에 넣은 물건들의 가치(v)의 합이 최대가 되는 것을 찾는 것이다. <br>

제한 조건은 세 문건의 무게(w)를 합치면 60이기 때문에 다 넣기 못한다는 것이다. 또한 물건은 **한 개씩만 넣을 수 있고 짐은 쪼갤 수 없다는 것**이다. <br>

|               i               |  1   |  2   |  3   |
| :---------------------------: | :--: | :--: | :--: |
|         V<sub>i</sub>         |  60  | 100  | 120  |
|         W<sub>i</sub>         |  10  |  20  |  30  |
| V<sub>i</sub> / W<sub>i</sub> |  6   |  5   |  4   |

  우리는 직관적으로 2, 3번의 물건을 넣어 무게는 50에 맞추고 가치는 220으로 하면 최대의 값을 찾을 수 있지만, 이를 컴퓨터에게 찾게 하는 것은 <br>

쉬운 일이 아니다. 따라서 생각해 볼 만한 방법은 위에처럼 무게대비 가치 순서로 고르게 하는 것이다. <br>

하지만 이렇게 하면 1,2를 선택하고 3은 버려지게 된다. 즉, 결국에는 노가다로 찾아보아야하는데 이러한 노가다 조차 어떠한 알고리즘을 사용할 지 <br>

생각해봐야 한다. 다음과 같이 접근할 수 있다. <br>

가치를 나타내는 함수를 Val이라고 할 때, Val(i, w)는 ~i 번째까지의 물건에 대해 w 무게까지 허용됐을 때의 최대 가치를 의미한다. <br>

Val(i, w) = Val(i-1, w - weight[i]) + value[i] 는 i번째 물건을 담기 전 상태에서 i 번째 물건을 담은 것을 의미한다. <br>

여기서 조건은 w >= weight[i] 이므로 다음과 같은 점화식을 생성할 수 있다. <br>

Val(i, w) = (w >= weight[i] ? max( Val(i-1, w - weight[i]) + value[i],  Val(i-1, w) ) : Val(i-1, w) <br>

즉 조건을 만족하면, 두 개의 값중에 큰 값을 Val(i, w)로 하고 조건을 만족하지 못한다면 바로 그 전 상태인 것을 저장하는 것이다. <br>



## 참조 

아래의 블로그를 참고하여 작성하였습니다. <br>

[zerocho 동적프로그래밍](https://www.zerocho.com/category/Algorithm/post/584b979a580277001862f182) <br>

[Sean 동적프로그래밍](https://os94.tistory.com/94)<br>

[Wikipedia 동적프로그래밍](https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95) <br>

