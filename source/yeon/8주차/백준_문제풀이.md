# 백준 문제

- [2098 : 외판원 순회](#2098-외판원-순회)
- [2156 : 포도주 시식](#2156-포도주-시식)
- [10942 : 팰린드롬](#10942-팰린드롬)
- [10844 : 쉬운 계단수](#10844-쉬운-계단수)



## 2098 외판원 순회

[문제로 이동](https://www.acmicpc.net/problem/2098)

### 접근 방법 

#### Python

처음에는 Greedy algorithm으로 풀어보았는데 당연히 시간초과가 발생하였다. <br>




#### C++

python과 동일한 로직으로 풀었지만, 계산을 해주는 부분이 값이 int의 범위값을 넘어가는 경우가 있으므로 **long long** 으로 해주어야한다. <br>



## python code

```python

```

### 메모리 및 수행 속도

메모리 :  KB <br>

시간 : ms <br>



## c++ code

```c++

```

### 메모리 및 수행 속도

메모리 :  KB <br>

시간 :  ms <br>



## 2156 포도주 시식

[문제로 이동](https://www.acmicpc.net/problem/2156)

### 접근 방법 

#### Python

이 문제는 

#### C++

다른 방법을 찾



## python code

```python

```

### 메모리 및 수행 속도

메모리 : 29516 KB <br>

시간 : 484 ms <br>

## c++ code

```c++

```

### 메모리 및 수행 속도

메모리 : 1984 KB <br>

시간 : 0 ms<br>



## 10942 팰린드롬 

[문제로 이동](https://www.acmicpc.net/problem/10942)

### 접근 방법 

#### Python

``` python
# 시간초과 발생 코드 solved by greedy 
N = int(input())
arr = list(map(int, input().split()))
M = int(input())

for _ in range(M):
	S, E = map(int,input().split())
	splitedArr = arr[S-1:E]
	if splitedArr == splitedArr[::-1]:
		print(1)
	else: print(0)
```

처음에는 S,E의 범위만큼 잘라서 해당 범위 만큼 기존의 arr에서 자른 뒤 팰린드롬인지 검사를 수행해서 맞으면 1, 아니면 0을 출력하도록 했는데 <br>

시간 초과로 인해서 시간을 단축할 수 있는 dp를 사용해야만 했다. 또한 이 문제는 dp를 사용하더라도 입력에서 기존의 입력처럼 받으면 시간초과가 <br>

발생하여 sys.stdin.readlin()을 사용하여 입력을 받아왔다. <br>

문제를 푸는 방법은 다음과 같다. 범위가 S,E 라고 할 때 팰린드롬인 경우는 크게 3가지이다. <br>

1. S == E, 즉 범위안에 **원소가 1개인 경우**에는 무조건 팰린드롬이다.
2. **범위안에  원소가 2개**이고 이 두개의 원소가 같은 경우 무조건 팰린드롬이다.
3. 범위안에 원소가 3개 이상인 경우에는 맨앞과 맨뒤의 원소의 값이 같은지만 비교하고 안에 있는 것은 계산했던 dp값이 1이면 팰린드롬이다. 



#### C++

python과 같은 로직으로 풀었다.



## python code

```python
# 백준 10942 팰린드롬
# python solved by dynamic programming
import sys

N = int(input())
arr = [int(i) for i in sys.stdin.readline().split()]
dp = [[0 for _ in range(N)] for _ in range(N)]

# if s and e is same it's always be palindrome 
# this is case of just one element
for i in range(N):
    dp[i][i] = 1

# if the range of s and e is 2 
# and if element of s and e are same then it's palindrome
for i in range(N-1):
    if arr[i] == arr[i+1]:
        dp[i][i+1] = 1

# if the range of s and e is over than 2 (3~)
# we can just compare the first and last element and see
# if there's palidrome between the range from dp[][] 
for l in range(2,N):
    for i in range(N-l):
        if arr[i] == arr[i+l] and dp[i+1][i+l-1] == 1 :
            dp[i][i+l] = 1


M = int(input())
for _ in range(M):
    s, e = [int(i) for i in sys.stdin.readline().split()]
    print(dp[s-1][e-1])
```

### 메모리 및 수행 속도

메모리 : 61644 KB <br>

시간 : 2620 ms <br>



## c++ code

```c++
// 백준 10942 팰린드롬
// cpp solved by dynamic programming
#include<iostream>
#include<vector>
int N, M, s, e;
int arr[2000];
std::vector<std::vector<int>> dp;

int main(void){
    scanf("%d", &N);
    for(int i = 0; i < N; i++){
        scanf("%d", &arr[i]);
    }
    // assign nxn size of vector 
    for(int i = 0; i < N; i++){
        std::vector<int>element(N);
        dp.push_back(element);
    }

    // one element must be the palindrome
    for(int i = 0; i < N; i++) 
        dp[i][i] = 1;

    // two element gonna be palindrome 
    // if first and second element is same
    for(int i = 0; i < N-1; i++){
        if(arr[i]==arr[i+1]) 
            dp[i][i+1] = 1;
    }
    
    // if range is more than 3 
    // just check the first and last element are same
    // and check dp[first+1][last-1] == 1 
    for(int l = 2; l < N; l++){
        for(int i = 0; i < N-l; i++){
            if(arr[i]==arr[i+l] && dp[i+1][i+l-1]==1){
                dp[i][i+l] = 1;
            }
        }
    }
    scanf("%d", &M);
    for(int i = 0; i < M; i++){
        scanf("%d %d", &s, &e);
        printf("%d\n",dp[s-1][e-1]);
    }
}

```

### 메모리 및 수행 속도

메모리 : 17704 KB <br>

시간 : 336 ms<br>



## 10844 쉬운 계단수

[문제로 이동](https://www.acmicpc.net/problem/10844)

### 접근 방법 

#### Python

이 문제는 위에

#### C++

python과 같은 로직으로 해결하였다.  <br>



## python code

```python
# 백준 10844 쉬운계단수
# python solved by dp
N = int(input())
MOD, _sum = 1000000000, 0

# assign 11x101 dp arr 
dp = [[0 for _ in range(11)]for _ in range(101)]

# in case of one digit
for i in range(1,10):
    dp[0][i] = 1

# we can find out that 
# dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]
for i in range(1,N+1):
    dp[i][0] = dp[i-1][1]
    dp[i][10] = 0
    for j in range(10):
        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1]) % MOD

for i in range(10):
    _sum = (_sum + dp[N-1][i]) % MOD 
print(_sum)
```

### 메모리 및 수행 속도

메모리 : 29380 KB <br>

시간 : 72 ms <br>



## c++ code

```c++
// 백준 10844 쉬운계단수
// cpp solved by dp 
#include<iostream>
#define MOD 1000000000
int main(void){
    // just assign 2x12 arr 
    int N, arr[2][12]={0,};
    scanf("%d", &N);
    int sum = 9;
    
    for(int i = 2; i <11; i++){
        arr[1][i] = 1;
    }

    for(int i = 2; i <= N; i++){
        sum = 0;
        // by using modular calculation, don't have to assign 11x102 size of arr
        // moving up & down so that decrease use of space complexity
        for(int j = 1; j < 11; j++){
            arr[i%2][j] = (arr[(i-1)%2][j-1]+arr[(i-1)%2][j+1]) % MOD;
            sum = (sum + arr[i%2][j]) % MOD;
        }
    }
    printf("%d",sum);
    return 0;
}
```

### 메모리 및 수행 속도

메모리 : 1984 KB <br>

시간 : 0 ms<br>



---

### 참조

[2104 부분배열 고르기 참고](http://blog.naver.com/PostView.nhn?blogId=hongjg3229&logNo=221731014713)  <br>

[1725 히스토그램 sweep algorithm](https://j2wooooo.tistory.com/74) <br> 

