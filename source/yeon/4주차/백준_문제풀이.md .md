# 백준 문제
  - [1978 : 알파벳](https://www.acmicpc.net/problem/1987)
  - [1261 : 알고스팟](https://www.acmicpc.net/problem/1261)
  - [1038 : 감소하는 수](https://www.acmicpc.net/problem/1038)

## 1978 : 알파벳
### 접근 방법 
#### Python
입력의

1. 사용자로부터 받은 입력을 2차원 리스트의 형태로 저장 e.g. [['B','W',...],['W','B',...]]<br>
2. 다음은 for문 4개를 중첩하여 2가지 answer의 형태와 비교하고, 다른 숫자들을 카운트해서 하나의 리스트에 넣는다. <br>
3. 사용자가 입력한 row, col까지 비교를 수행하여 카운트한 숫자들 중에서 가장 작은 숫자를 정답으로 제출한다. <br>
여기서의 중요한 점은 2가지 answer과 비교를 해야하는 것이며 또한 answer내에서의 규칙을 찾는 것이 중요한 부분이다. <br>
예를 들면 Black이 먼저 나오는 경우 2차원 리스트의 행과 열의 인덱스의 합이 짝수이면 항상 B가 정답, 홀수이면 W가 정답이라는 것이다. 

#### C++
접근하는 방법은 Python과 동일하게 접근하면 된다. 

## python code
```python
# 백준 1978 알파벳 
# python solved by bfs & backtracking

# left, down, right, up
dx = [-1,0,1,0]
dy = [0,-1,0,1] 

def bfs(x:int, y:int):
    global answer
    q = set([(x,y,board[x][y])])

    while q:
        x,y,ans = q.pop()
        #check left, down, right, up 
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            
            # if nx, ny are in the boundary and 
            # not in ans which saves the visited alpahbet 
            # then append it to ans, and get the answer
            if((0 <= nx < R) and (0 <= ny < C) and (board[nx][ny] not in ans)):
                q.add((nx,ny,ans + board[nx][ny]))
                answer = max(answer, len(ans)+1)

R, C = map(int,input().split()) #input = sys.stdin.readline()
board = [list(input().strip()) for _ in range(R)]
answer = 1
bfs(0,0)
print(answer)
```
### 메모리 및 수행 속도
메모리 : 49344 KB <br>
시간 : 2236ms

## c++ code
```c++
// 백준 1978 알파벳
// cpp solved by dfs 

#include <iostream>
#include <string>
using namespace std;

char map[21][21];
int R, C, answer;
int dx[] = {1,-1,0,0};
int dy[] = {0,0,-1,1};

// arr that checks visited or not and 
// 26 means 'A' to 'Z' 
bool visited[26]; 

void dfs(int x, int y, int cnt){
    answer = max(answer,cnt);

    for(int i = 0; i < 4; i++){
        int nx = x + dx[i];
        int ny = y + dy[i];

        if(nx >= 0 && nx < R && ny >= 0 && ny < C){
            // if nx, ny are in the boundary
            // ans if map[nx][ny] are not visited
            if(visited[map[nx][ny] - 'A'] == false){
                // change it to visited and 
                // reapeat dfs until they can't find any other way 
                // and if they can't find way, it will cancel the visited status
                // and came back to right before stage 
                // and look for another way (which is dfs)
                visited[map[nx][ny] - 'A'] = true;
                dfs(nx,ny,cnt + 1);
                visited[map[nx][ny] - 'A'] = false; 
            }
        }
    }
}

int main (void){
    scanf("%d %d", &R, &C);
    for(int i = 0; i < R; i++){
        for(int j = 0; j < C; j++)
            cin >> map[i][j];
    }
    // first place 0,0 is always visited
    // so setting it as visited
    visited[map[0][0]-'A'] = true;
    dfs(0,0,1);
    printf("%d\n", answer);
    return 0;
}
```
### 메모리 및 수행 속도
메모리 : 1988 KB <br>
시간 : 440ms

-----

cpp로 작성한 틀린 코드 

```C++
// 백준 1978 알파벳
// cpp solved by bfs, backtracking 
struct maze {
    int x;
    int y;
    string c;
};

void bfs(int x, int y){
    queue<maze> q;
    string str  = "";
    str.push_back(map[x][y]);
    q.push({x,y,str});
    int answer = 1;
    
    while(!q.empty()){
        int x = q.front().x;
        int y = q.front().y;
        string ans = q.front().c;
        q.pop();
        for(int i = 0; i < 4; i++){
            int nx = x + dx[i];
            int ny = y + dy[i];

            if( nx >= 0 && nx < R && ny >=0 && ny < C && ans.find(map[nx][ny]) == -1){
                q.push({nx,ny,ans + map[nx][ny]});\
                cout<<ans+map[nx][ny]  <<endl;
                answer = max(answer,int(ans.length())+1);
            }   
        }
    }
    printf("%d\n", answer);
}
```

python에서 풀은 것처럼 bfs, backtracking을 이용하여 풀어보았지만 **메모리 초과**가 나오게 되었다. <br>

그 이유를 찾아보았더니 queue를 사용한 것이 문제라고 하였다. 막연히 queue가 커져서 메모리 초과가 나온다는 것이 <br>

감이 오지 않아서 20 x 20 일 때의 queue에 push되는 것을 print 해본 결과 이해를 하였다. <br>

``` 
input : 20 20																output : 26
				POIUYTREWQBWKALSLDLG
				LKJHGFDSAMASFBMBOSOZ
				NMBVCXZAKPAISJLBMROW
				CEVTBFNIMLASNCVKNDKX
				VPQLBKENMSAHBBLFOWPQ
				ZLSKJJBNBEASZNFDGHHN
				GPBMDLQDALAASBBXCEGA
				APQIKBMROIBANPOBLMKS
				ASKSKVJRPORHNOXZKSPN
				LSNVOEOOOKAKANLGKOAX
				AKVMBOTOWPQOJBSMSPEP
				BLLBKWPEPBKNMROSALLP
				BNQLDNBMKOVMEMELSLMA
				RLEPQQPVKJRNBITNBSAS
				ZXMCOITRPWKLPGKHNGMS
				QOBKRPPPZSLEMPNKSPPR
				OQJDNZNANDWKQKVJEOGJ
				QUYVOIUYWERLKJHASDFV
				ZCVWRETPOIUHJKLVBMAS
				QWERZCVUIAFDKHSDFHSA
```

실제로 정답이 26이 나오긴 하지만 시간이 오래 걸렸고, 그 이유를 bfs로 생각을 해보면 다음과 같다.  <br>

맨 처음 P를 기준으로 하여 {O L}이 큐에 있고, O를 pop하면 {L I K}, L을 pop하면 {I K N}가 되는데 <br>

여기서 queue에 push 할 때 기존의 ans에 현재 알파벳을 추가하여 저장하므로 실제로 코드 실행 중에 queue에는 <br>

POIUYGCXZDREWQMASFBJLVKN <br>
POIUYGHVTBCXFNZDREWAKMLS <br>
POIUYGHVTBCXFDSAZNEKJLQM <br>
POIUYGHVCXFKJLQMRDNBEASZ <br>
POIUYGHVCXFKJLQBENZASDRT <br>
POIUYGHVCXFTRDSAZNEBQLJK <br>

이런식으로 들어가게 되는데 python에서는 set으로 지정한 **반면 cpp에서는 set이 아니므로** abcd, bcde, cdef, defg <br>

라고 하면 abcdefg를 10개 정도를 집어넣게 된다. 따라서 메모리 초과가 일어난 것 같다. <br>

따라서 위의 코드에서도 set의 형태로 ans를 넣어준다면 메모리 초과 문제를 해결 할 수 있을 것 같다.<br>



## 1261 : 알고스팟

### 접근 방법 
#### Python
처음에 문제의 **입력범위**를 보고 적어도 **O(nlog n)이나 O(n)의 복잡도** 로 풀어야한다는 것을 알았다. <br>
그래서 처음에는 이진탐색이 아닌, n개의 나무를 h의 길이만큼 맞춰서 자른다면 평균적으로 잘라야하는 길이를 <br>
mid로 생각하고 mid를 기준으로 +1, -1을 하는 알고리즘을 사용했지만 시간초과로 인해서 이진탐색을 사용하게 되었다. <br>
내가 사용한 알고리즘의 경우에는 극단적인 경우에도 시간초과가 발생하지만, mid의 값이 결국 +1, -1씩 변경되므로 <br>
이진탐색보다는 훨씬 느리다는 것을 알게되었다. <br>

1. 사용자로부터 나무의 개수, 구해야하는 길이, 나무들의 높이를 입력받는다. <br>
2. 이진 탐색 알고리즘을 사용하기 위해서 left = 0, right = max(tree) 즉 최솟값과 최댓값을 기준으로 한다. <br>
3. mid = (left+right) // 2를 시작으로 하여 구해야하는 height 값에 도달할 때까지 left, right의 값을 mid+1, mid-1로 변경하여 반복 수행한다. <br> 
![img load fail](../images/compilecompare.png) <br>
이유는 모르겠으나 while문안에 for문을 돌리는 경우와 for문이 들어간 부분만 함수로 따로 빼서 계산을 한것의 수행속도 차이가 발생하여 시간초과가 발생하였다. <br>
위의 사진처럼 첫번째 3초대가 for문을 함수로 뺀 경우, 두번째 5초대가 while문안에 for문이 들어가 있는 경우의 수행속도 차이이다. <br>

#### C++
알고리즘은 python과

## python code
```python
# 백준 1261 알고스팟
# python solved by bfs using deque
from collections import deque

# left, down, up, right
dx = [-1,0,0,1]
dy = [0,-1,1,0]

def bfs(x: int, y: int):
    q.append([x,y])
    while q:
        # deque를 사용해서 arr가 0인 nx,ny는 우선순위가 높게 하기 위해
        # appendleft를 하였기 때문에 popleft를 해준다. 
        x, y = q.popleft()

        for i in range(4):
            nx, ny = x + dx[i] , y + dy[i]

            if 0 <= nx < M and 0 <= ny < N :
                if dist[nx][ny] == -1:
                    if arr[nx][ny] == 0 :
                        q.appendleft([nx,ny])
                        dist[nx][ny] = dist[x][y]
                    elif arr[nx][ny] == 1:
                        q.append([nx,ny])
                        dist[nx][ny] = dist[x][y]+1

N, M = map(int,input().split())
arr = [list(map(int,input())) for _ in range(M)]
q = deque()
# 입력받은 arr의 원소가 1이냐 0이냐에 따라서 비용을 계산하는 리스트 
dist = [[-1] * N for _ in range(M)]
dist[0][0] = 0
bfs(0,0)

print(dist[M-1][N-1])
```
### 메모리 및 수행 속도
메모리 : 31824 KB <br>
시간 : 104 ms

## c++ code
```c++
// 백준 1261 알고스팟
// cpp solved by bfs using deque
#include <iostream>
#include <deque>
using namespace std;
int map[101][101];
int dist[101][101];
int M,N;
int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, -1, 1};

struct maze{
    int x, y;
};

void bfs(int x, int y){
    dist[0][0] = 0;
    deque<maze> dq;
    dq.push_back({x,y});
    
    while(!dq.empty()){
        int x = dq.front().x;
        int y = dq.front().y;
        dq.pop_front();

        for (int i = 0; i < 4; i ++){
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < N && ny >= 0 && ny < M){
                if (dist[nx][ny] == -1){
                    if(map[nx][ny] == 0){
                        dq.push_front({nx,ny});
                        dist[nx][ny] = dist[x][y];
                    }
                    else if(map[nx][ny] == 1){
                        dq.push_back({nx,ny});
                        dist[nx][ny] = dist[x][y] + 1;
                    }
                }
            }
        }
    }
    printf("%d\n", dist[N-1][M-1]);
}


int main (void){

    scanf("%d %d",&M, &N);
    for(int i = 0; i< N; i++){
        for (int j = 0; j < M; j++){
            //정수 하나씩 받는거는 %1d
            scanf("%1d",&map[i][j]); 
            dist[i][j] = -1;
        }
    }
    bfs(0,0);
    return 0;
}
```
### 메모리 및 수행 속도
메모리 : 2064 KB <br>
시간 : 0 ms<br>



## 1038 : 감소하는 수 

### 접근 방법 
#### Python
이 문제를 풀 때 가장 중요했던 점은 index(즉 한번 스택에 들어왔던 숫자들중 가장 큰 수)와 max(현 스택에서 남아있는 가장 큰 수)를 <br>
잘 관리하면 쉽게 풀 수 있는 문제이다. <br>

1. 먼저 사용자로부터 개수, 리스트를 입력 받는다. <br>
2. stack이 비어있는 경우, 원소가 stack에 있는 경우로 나눠 코드를 작성하였다. <br>
3. stack이 비어있는 경우, 해당 원소까지 채워주고 마지막 원소를 pop하여 배열에 저장한다. 이때 max의 값은 stack이 pop이후에 
size가 0이냐 0이 아니냐에 따라서 0 혹은 stack[-1](즉 현재 리스트 안에 가장 마지막 원소=최대값)을 max로 가진다.<br>
4. stack의 max가 배열의 원소보다 큰 경우 index부터 배열 원소까지 채우고 pop, max 값 변경을 해준다. <br>
5. stack의 max가 배열의 원소보다 작거나 같은 경우, pop을 하여 comp 리스트에 저장한다. <br.
6. comp와 처음에 사용자로부터 입력 받은 리스트와 비교해서 같으면 answer을 출력 아니면 NO를 출력 <br>

#### C++
기존의 python과 같은 방법으로 풀었지만, python에서는 함수에서 return 값으로 max, cnt, stack, answer를 해주었지만 c++에서는 불가능하였기 때문에 <br>
python에서는 배열을 미리 다 입력 받은 반면에, c++에서는 사용자로부터 입력을 받는 즉시 하나씩 그에 따라서 알고리즘을 수행해주었다.<br>
또한 python에서는 리스트를 stack처럼 사용한 반면에 c++코드에서는 **STL라이브러리인 stack을 사용** 하여 **top, push, pop함수**를 활용하였다.<br>
코드를 짜고나서 보니 로직을 이미 python으로 짜고나서인지 c++로 작성한 것이 더 깔끔하였다.

## python code
```python
def push(stack, i, index, max, answer):
    for j in range(index + 1, i + 1):
        stack.append(j)
        answer += "+\n"
    index = i
    comp.append(stack.pop())
    answer += "-\n"

    if len(stack) == 0: max = 0
    else : max = stack[-1]
    return stack, index, max, answer 

if __name__ == "__main__":
    arr = [] # 처음에 입력받는 배열
    comp = [] # pop에서 나오는 숫자들을 저장했다가 나중에 arr와 비교하기 위한 배열 
    stack = [] # 입력받은 배열을 순차적으로 넣었다가 빼보면서 가능한지 해보는 배열 
    answer = "" # +, - 를 저장하여 출력하기 위한 변수 
    max = 0 # 현재 stack 리스트에서의 가장 마지막에 있는 변수
    index = 0 # stack 리스트에 들어왔던 숫자들 중 가장 큰 수를 기억하기 위한 변수 
    
    num = int(input())
    for i in range (0, num):
        n = int(input())
        arr.append(n)
    
    # 사용자로부터 입력 받은 배열의 값을 가지고 for문을 돌림
    for i in arr:
        # stack의 길이가 0 인 경우 
        # 1. 아예 맨 처음에 비어있는 상태인 경우 
        # 2. 원소들이 들어왔다가 pop으로 인해서 빠져나가는 경우
        if i > max :
            stack, index, max, answer = push(stack,i,index,max,answer)
        # 현재 stack 안에 있는 max 값이 arr의 해당 원소보다 큰 경우 
        # 즉, stack 리스트 안에 i 값이 있는 경우  
        elif i <= max:
                comp.append(stack.pop())
                answer = answer + "-\n"
                if len(stack) == 0: max = 0
                else : max = stack[-1]

    if comp != arr:
        print("NO")
    else : 
        print(answer)
```
### 메모리 및 수행 속도
메모리 : 37512 KB <br>
시간 : 7744 ms

## c++ code
```c++
#include<iostream>
#include<string>
#include<vector>
#include<stack>

using namespace std;

int main(void){
    int len, n =0;
    scanf("%d", &len);
    
    vector<int> v;
    vector<int> comp;
    stack<int> stack;
    string answer = "";
    int max = 0, index = 0;
    
    for(int i = 0; i < len; i++){
        cin >> n;
        v.push_back(n);
        if (v[i] > max){
            for (int j = index + 1; j <= v[i]; j++ ){
                stack.push(j);
                answer += "+\n";
            }
            index = v[i];
            comp.push_back(stack.top());
            stack.pop();
            answer += "-\n";

            if(stack.size()!= 0) max = stack.top();
            else max = 0;
        }
        else{
            comp.push_back(stack.top());
            stack.pop();
            answer += "-\n";
            if(stack.size()!= 0) max = stack.top();
            else max = 0;
        }
    }
    if(v == comp) cout<<answer;
    else printf("NO");

    return 0;
}
```
### 메모리 및 수행 속도
메모리 : 4016 KB <br>
시간 : 48 ms<br>

### 참조
[이정개 블로그](https://leejunggae.tistory.com/14) <br>
[python 입력 받기](https://velog.io/@dlrmwl15/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0)