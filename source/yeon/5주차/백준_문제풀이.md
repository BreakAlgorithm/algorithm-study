# 백준 문제

  - [2309 : 일곱 난쟁이](#2309-:-일곱-난쟁이)
  - [2503 : 숫자야구](#2503-:-숫자야구)
  - [1182 : 부분 수열의 합](#1182-:-부분-수열의-합)

- [3085 : 사탕 게임](#3085-:-사탕-게임)



## 2309 : 일곱 난쟁이 

[문제로 이동](https://www.acmicpc.net/problem/2309)

### 접근 방법 

#### Python

주어진 9명의 난쟁이들의 키들 중에서 합이 100이 되는 7명의 난쟁이가 되는 경우를 아무거나 하나 출력하면 된다. <br>

python은 순열과 조합을 매우 쉽게 사용할 수 있기 때문에 조합을 사용하기로 하였다. <br>

**조합(Combinations)과 순열(permutations)의 차이점**은 다음과 같다. <br>

**순열**은 **순서가 있는 조합**으로, 즉 원소의 **순서가 의미가 있는 것**인 반면 **조합**은 **원소의 순서가 상관이 없다**. <br>

1. 사용자로부터 키를 입력받아서 list에 넣어준다. <br>

2. 이 문제의 경우 합만 100이면 되는 것이지 **순서에는 의미가 없기 때문에 <sub>9</sub>C<sub>7</sub>  의 조합**을 구해서 list 에 저장한다.<br>

   이때 조합이 배열에 저장될 때는 **tuple 형태로 저장됨**을 유의해야한다. 

3. 조합을 구한 list의 경우들 중에서 합이 100되는 경우를 반복문을 통해서 찾는다. <br>

4. 100이 되는 경우를 찾으면 해당 경우를 **tuple에서 list로 변경**하고 sort를 진행한 뒤 정답 형태에 맞게 출력한다.<br>



#### C++

python과 동일하게 c++에도 조합과 순열을 사용할 수 있지만 이번에는 라이브러리를 사용하지 않고 풀기로 하였다. <br>

![img load fail](../image/2309cpp.png) <br>

위의 그림과 같이 입력 받은 원소들 중에서 2개씩 빼고 더해서 합이 100이 되는 경우를 찾아서 정렬 후 출력한다.<br>

1. 사용자로부터 받은 입력을 배열 형태로 저장한다.
2. 2개의 원소를 제외하고 더해서 100이 되는 경우가 나올 때 까지 반복해서 진행한다.
3. 100이 되는 경우 index k, i 번째의 원소 값을 0으로 바꿔준 뒤 sort를 진행한다.
4. 따라서 k, i는 0,1 번째에 위치하게 되고 2번째 원소부터 마지막 원소까지 출력해주면 된다.



## python code

```python
# 백준 2309 일곱 난쟁이
# python solved by combinations + brute-force
from itertools import combinations
# combinations(조합)과 permutations(순열)의 차이
# 순열은 순서가 있는 조합 즉, 순열은 원소의 순서가 상관이 있음 
# 조합은 순서가 상관 없다

height = []
for i in range(9):
    n = int(input())
    height.append(n)

# make combinations with height list having 7 elements
a = list(combinations(height,7))

for i in a:
    sum = 0
    for j in range(7):
        sum += i[j]
    if sum == 100:
        ans = list(i)
        ans.sort()
        for i in ans:
            print(i,end="\n")
        exit()
```

### 메모리 및 수행 속도

메모리 : 29380 KB <br>

시간 : 60ms

## c++ code

```c++
// 백준 2309 일곱 난쟁이
// cpp solved by brute-force 
#include <iostream>
#include <algorithm>

int main(void){
    // get height from user
    int arr[9], num = 0;
    for (int i = 0; i < 9; i++){
        scanf("%d", &num);
        arr[i] = num;
    }
    
    int sum = 0, cnt = 0, k = 0;
    while (1){
        int i, j;
        for (i = k + 1; i < 9; i++){
            sum = 0, cnt = 0;
            for (j = 0; j < 9; j++){
                if (j == k);
                else if (j == i);
                else{
                    sum += arr[j];
                    cnt++;
                }
            }

            if (sum == 100 && cnt == 7){
                // make k's, i's value zero and sort
                // and print sum from 2nd element which means
                // sum arr except k, i's index
                arr[k] = 0, arr[i] = 0;
                std::sort(arr, arr + 9);
                for (int i = 2; i < 9; i++){
                    printf("%d\n", arr[i]);
                }
                exit(0);
            }
        }
        k++;
    }
    return 0;
}
```

### 메모리 및 수행 속도

메모리 : 1984 KB <br>

시간 : 0 ms



## 2503 : 숫자야구

[문제로 이동](https://www.acmicpc.net/problem/2503)

### 접근 방법 

이러한 문제에서 NxM 이라고 나와도 문제를 읽다보면 가로가 M이고 세로가 N인 경우가 있으므로 제대로 확인해보자!<br>

#### Python

미로에서의 벽을 부수고 목적지 까지 도착해야하는데 부순 횟수를 구해야하는 문제이다. <br>

기존의 bfs로는 풀 수 없는게, 왜냐하면 **bfs는 모든 간선의 가중치가 동일해야 한다는 전제 조건**이 필요한데 <br>

이 문제의 경우 0 인 경우는 통과가 가능하고 1인 경우는 벽을 부숴야하므로 가중치가 동일하지 않다. <br>

따라서 **다익스트라 알고리즘이나, deqeue를 사용하여 푸는 방법**이 있다. <br>

이때 중요한 점은 0인 경우가 더 가중치가 높고, 1인 경우가 가중치가 낮으므로, 항상 popLeft()를 하므로<br>

0 일 때는 appendLeft()를 하여 0인 경우를 먼저 보도록한다. <br>



1. 사용자로부터 받은 미로를 2차원 리스트의 형태로 저장 e.g. [[0,1,1],[1,1,1,],[1,1,0]]  <br>

2. 미로에서 0일 때와 1일 때의 따라서 벽을 부순 횟수를 기록하는 dist[]배열을 -1로 초기화한다.   <br>

3. x,y가 0,0일 때 항상 열려있으므로 dist\[0][0]은 0으로 셋팅해준다.

4. deque에 처음 0,0을 넣어주고 큐가 빌때까지 아래의 과정을 반복한다.

5. 처음에 queue에 넣어준 x,y를 **pop left()** 해주고 현재 위치에서 상, 하, 좌, 우를 움직여서 범위안에 있는지 확인한다.

6. 만약 범위안에 있을 때 dist\[nx][ny]가 -1, 아예 방문했던 적이 없는 경우

   6-1 미로의 nx,ny에서의 **값이 0**이면 dist\[nx][ny]의 값은 **dist\[x][y] 그대로 유지**하고 **queue에 appendleft()** <br>

   6-2 미로의 nx, ny **값이 1**이면 dist\[nx][ny]의 값은 **dist\[x][y]에서 + 1**을 해주고 **queue에서 append()** <br>

7. 위의 과정을 범위를 벗어나기 전까지 반복한 뒤 dist\[N-1][M-1]의 값을 출력해준다.

  

#### C++

python과 동일한 로직을 사용하여 똑같이 deqeue를 사용하여 풀었다. <br>

숫자를 011에서 **scanf로 하나씩 저장할 때**는 **%1d**를 통해서 하나씩 저장한다는 것을 깨달았다. <br>

## python code

```python
# 백준 1261 알고스팟
# python solved by bfs using deque
from collections import deque

# left, down, up, right
dx = [-1,0,0,1]
dy = [0,-1,1,0]

def bfs(x: int, y: int):
    q.append([x,y])
    while q:
        # deque를 사용해서 arr가 0인 nx,ny는 우선순위가 높게 하기 위해
        # appendleft를 하였기 때문에 popleft를 해준다. 
        x, y = q.popleft()

        for i in range(4):
            nx, ny = x + dx[i] , y + dy[i]

            if 0 <= nx < M and 0 <= ny < N :
                if dist[nx][ny] == -1:
                    if arr[nx][ny] == 0 :
                        q.appendleft([nx,ny])
                        dist[nx][ny] = dist[x][y]
                    elif arr[nx][ny] == 1:
                        q.append([nx,ny])
                        dist[nx][ny] = dist[x][y]+1

N, M = map(int,input().split())
arr = [list(map(int,input())) for _ in range(M)]
q = deque()

# 입력받은 arr의 원소가 1이냐 0이냐에 따라서 비용을 계산하는 리스트 
dist = [[-1] * N for _ in range(M)]
dist[0][0] = 0
bfs(0,0)

print(dist[M-1][N-1])
```

### 메모리 및 수행 속도

메모리 : 31824 KB <br>

시간 : 104 ms

## c++ code

```c++
// 백준 1261 알고스팟
// cpp solved by bfs using deque
#include <iostream>
#include <deque>
using namespace std;
int map[101][101];
int dist[101][101];
int M,N;
int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, -1, 1};

struct maze{
    int x, y;
};

void bfs(int x, int y){
    dist[0][0] = 0;
    deque<maze> dq;
    dq.push_back({x,y});
    
    while(!dq.empty()){
        int x = dq.front().x;
        int y = dq.front().y;
        dq.pop_front();

        for (int i = 0; i < 4; i ++){
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < N && ny >= 0 && ny < M){
                if (dist[nx][ny] == -1){
                    if(map[nx][ny] == 0){
                        dq.push_front({nx,ny});
                        dist[nx][ny] = dist[x][y];
                    }
                    else if(map[nx][ny] == 1){
                        dq.push_back({nx,ny});
                        dist[nx][ny] = dist[x][y] + 1;
                    }
                }
            }
        }
    }
    printf("%d\n", dist[N-1][M-1]);
}


int main (void){

    scanf("%d %d",&M, &N);
    for(int i = 0; i< N; i++){
        for (int j = 0; j < M; j++){
            //정수 하나씩 받는거는 %1d
            scanf("%1d",&map[i][j]); 
            dist[i][j] = -1;
        }
    }
    bfs(0,0);
    return 0;
}
```

### 메모리 및 수행 속도

메모리 : 2064 KB <br>

시간 : 0 ms<br>



## 1182 : 부분수열의 합 

### 접근 방법 

#### Python

이 문제를 접근할 때 가장 중요한 점은 아래의 사실을 깨닫는 것이다. <br>

#### C++

python과 같은 로직으로 풀어보려다가 다른 기발한 풀이를 발견하여 cpp로는 다른 풀이를 풀어보려고 한다. <br>



## python code

```python
# 백준 1182 부분수열의 합
# python solved by combinations and brute-force
from itertools import combinations

N, S = map(int, input().split())
arr = list(map(int,input().split()))

cnt = 0
# make combinations 1 to N
# and check the sum of each case 
# if there's any answer exist 
for i in range(1,N+1):
    a = list(combinations(arr,i))
    for j in a :
        sum = 0
        for h in range(i):
            sum += j[h]
        if sum == S :
            cnt +=1
print(cnt)
```

### 메모리 및 수행 속도

메모리 : 78548 KB <br>

시간 : 1988 ms

## c++ code

```c++
// 백준 1182 부분수열의 합
// cpp solved by combinations and brute-force
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
vector<int> arr; // save input from user
vector<vector<int>> result; // save combination result
vector<int> sub;
int N, S;

void combination(int k){
  	// if index is same as size of arr
    // push it to result[]
    if(k == N){
        result.push_back(sub);
    }else{
        sub.push_back(arr[k]);
        combination(k+1);
        sub.pop_back();
        combination(k+1);
    }
}

int main(void){
    int num, cnt = 0;
    long long sum;
    
    scanf("%d %d",&N, &S);
    for (int i = 0; i < N; i++){
        scanf("%d", &num);
        arr.push_back(num);
    }

    // start recurisve from index 0 
    combination(0);

    // check is value which prevent counting cnt 
    // even though there's nothing to calculate 
    int check;
    for(int i = 0; i <result.size();i++){
        sum = 0, check = 0;
        for(int j = 0; j < result[i].size();j++){
            sum += result[i][j];
            check++;
        }
        if(sum == S && check > 0) cnt++;
    }
    printf("%d", cnt);
    return 0;
}
```

### 메모리 및 수행 속도

메모리 : 81768 KB <br>

시간 : 124 ms<br>



### 참조

[GODOG's blog - 1182번 combination 재귀 함수를 이용하여 구현](https://godog.tistory.com/entry/C-%EC%A1%B0%ED%95%A9Combination-%ED%9A%8C%EA%B7%80%EB%A5%BC-%EC%9D%B4%EC%9A%A9)  <br>

[사용자 제크와 죠세핀 - queue사용시 메모리 초과이유](https://jech-jose.tistory.com/63) <br>

[BarrrrkingDog - 감소하는수 다른 풀이](https://blog.encrypted.gg/142) <br>



