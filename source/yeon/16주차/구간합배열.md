# 구간합(Prefix Sum)

구간합과 부분합이라는 것이 존재한다.<br>

구간합 : a ~ b 까지의 합을 의미 <br>

부분합 : 0 ~ k 까지의 합을 의미 <br>

이러한 구간합을 O(1)에 구하는 알고리즘이 있다. 

기존의 arr[10] = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18} 이라는 배열이 존재한다고 할 때 a ~ b까지의 구간합을 <br>

요구하는 쿼리가 2천만개가 들어왔다고 가정해보자. 일반적으로 다음과 같이 해결할 수도 있다.

```python
arr[10] = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18} 

N = int(input()) # 쿼리의 개수
for _ in range(N):
	a, b = map(int, input().split())
	sum = 0
	for i in range(a, b+1):
		sum += arr[i]
	
	print(sum)
```

이렇게 해결하는 경우 for문을 도는 최악의 경우 10 x 쿼리의 개수 20,000,000 이므로 O(200,000,000) 대략 2초이다. <br>

1초안에 해결해야하는 경우 이러한 풀이로는 해결이 불가능하므로 다음과 같은 구간합을 사용할 수 있다.

```python
arr[10] = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18} 
prefixSum = [0] * (N+1)

for i in range(10):
	prefixSum[i+1] = prefixSum[i] + arr[i]
	
for _ in range(N):
	a, b = map(int, input().split())
	print(prefixSum[b] - prefixSum[a-1])
```

미리 누적합을 계산해놓은 prefixSum이라는 배열을 사용하여 실제로는 O(1)이라는 시간만에 끝이난다. <br>

그리고 쿼리의 개수가 20,000,000 이라고 할 때 O(20,000,000) 이므로 0.2 초만에 해결할 수 있게 된다. <br>

이와 같이 구간의 합을 여러 번 구해야하는 경우 누적합을 사용하면 O(1)이라는 시간복잡도로 계산이 가능하게 된다. <br>



## 참조 

[구간합 배열 알고리즘](https://blog.naver.com/kks227/220787178657)

