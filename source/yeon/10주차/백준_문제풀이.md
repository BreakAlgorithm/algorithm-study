# 백준 문제

- [1300 : K번째 수](#1300-K번째-수)
- [2343 : 기타 레슨](#2343-기타-레슨)
- [3020 : 개똥벌레](#3020-개똥벌레)
- [14003 : 가장 긴 증가하는 부분 수열5](#14003-가장-긴-증가하는-부분-수열5)



## 1300 K번째 수

[문제로 이동](https://www.acmicpc.net/problem/1300)

### 접근 방법 

#### Python

도저히 접근을 어떠한 방식으로 해야하는지 몰라서 검색을 통해 해결하였다. <br>

이 문제를 해결하는 방법은 **Parametric Search**라는 Binary Search를 응용한 방법을 통해 해결할 수 있다. <br>

Parametric Search의 기본적인 탐색방법은 Binary Search와 동일하지만, 기존의 Binary Search는 주어진 배열의 값들을 기준으로 <br>

찾는 값이 존재하는지를 확인한다면, Parametric Search는 **내가 원하는 실수의 정답의 범위에서 이진탐색을 진행**한다고 생각하면 된다. <br>

![ParametricSearch](../images/ParametricSearch.png)

즉, 그림처럼 배열에서의 특정 값을 찾는 것이 아닌, 수직선 상 위에서 내가 원하는 값을 이진탐색으로 찾아가는 느낌이다. <br>

따라서 이 문제서는 **임의의 mid값을 정하고 나서 과연 이 mid가 k번째 수일까?** 라는 풀이를 진행할 것이다. <br>

그렇다면 mid보다 작은 원소의 개수는 몇개인지 파악해야한다. <br>

배열 A[i]\[j]에서 i 행에 속한 원소들은  i x **j** 이므로 모두 i 의 배수이다. 따라서  **min(mid/i, N)**이 i 번째 행에서 mid 보다 작은 숫자들의 개수이다. <br>

``` python
# i행의 원소들은 ix1, ix2, ix3 ,,, ,ixN 으로 구성되어있다.
# 이때 i행의 원소들중에 mid보다 작거나 같은 원소는 ixj <= mid를 만족하는 j의 개수이고 
# 이는 ix1, ix2, ix3, ,,, ,ixj 이므로 mid/i와 같은 값이다.
```

예를 들어 N = 1000인 경우에는, mid가 1000 x 1000 / 2 = 50만이 되는데 이 경우에는 50만/i 가 N을 넘어갈 수 있으므로 N과 비교를 통해 <br>

최소값을 개수로 선택한다.

따라서 N까지 위의 경우를 반복하여 mid보다 작은 원소의 개수를 파악한 뒤, K값과의 비교를 통해 이분 탐색을 진행하면 된다. 



#### C++

python과 동일한 로직으로 해결하였다. <br>



## python code

```python
# 백준 1300 k번째 수 
# python solved by binary search

N, k = int(input()), int(input())
left, right = 1, k

# parametric Search 
# check mid is k'th element or not 
# count the number of element under mid 
# and binary search according to compare result of cnt & k
while left <= right:
    # just set mid as half of arr
    # so time complexity can be log(k)
    mid = (left + right)//2

    cnt = 0
    # count the number of element under mid 
    for i in range(1,N+1):
        cnt += min(mid//i, N)

    # and binary search according to compare result of cnt & k
    if cnt >= k:
        ans = mid
        right = mid -1
    else:
        left = mid + 1

print(ans)
```

### 메모리 및 수행 속도

메모리 : 29380 KB <br>

시간 : 1092 ms <br>



## c++ code

```c++
// 백준 1300 k 번째수
// cpp solved by binary search

#include<iostream>
#include<algorithm>
int N, k;

int main(void){
    scanf("%d\n%d", &N,&k);
    int left = 1, right = k, ans = 0;
    while(left <= right){
        int mid = (left + right)/2;

        int cnt = 0;
        for(int i = 1; i < N + 1; i++){
            cnt += std::min(mid/i, N);
        }

        if (cnt >= k){
            ans = mid;
            right = mid - 1;
        }else{
            left = mid + 1;
        }
    }
    
    printf("%d", ans);
    return 0;
}
```

### 메모리 및 수행 속도

메모리 : 1984 KB <br>

시간 : 12 ms <br>



## 2343 기타레슨

[문제로 이동](https://www.acmicpc.net/problem/2343)

### 접근 방법 

#### Python

이분 탐색 문제는 **무엇을 탐색할 것인지 정하는 것**이 가장 중요하다. 기타레슨 문제에서의 탐색해야할 것은 **블루레이의 최소 크기를 찾는 것**이다. <br>

이때 블루레이의 크기를 10이라고 가정해보자. 그럼 1, 2, 3, 4, 5, 6, 7, 8, 9 라는 레슨에서 1, 2, 3, 4는 블루레이 하나에 담기고, <br>

5,6,7,8,9 는 하나씩 블루레이에 담기게 된다. 즉, {1,2,3,4},{5},{6},{7},{8},{9} 이런식으로 담기게 되는데 블루레이의 개수가 6개가 된다. <br>

하지만 M=3 이기 때문에 블루레이의 크기를 늘려야 한다는 것을 알 수 있다. 

따라서 **임의의 블루레이 크기를 정하여 레슨을 담고**, 개수가 M보다 커지만 사이즈를 늘려주고, M보다 적어지면 사이즈를 줄여야한다. <br>

그렇다면 low, high 값은 어떤 값을 잡아야 모든 경우에 대해서 탐색을 하는 것일까? <br>

바로 양 끝의 극단적인 값들을 넣어주면 된다. low의 경우에는 모든 레슨이 각각 하나의 블루레이에 들어갈 수 있게 레슨에서의 가장 큰 값을 <br>

high에는 모든 레슨이 전부 하나의 블루레이에 들어갈 수 있게 모든 레슨의 합으로 해주면 모든 값들을 확인할 수 있다. 



#### C++

pythonr과 동일한 방법으로 문제를 해결하였다. <br>



## python code

```python
# 백준 2343 기타레슨 
# python solved by binary search

def binarySearch(low : int, high : int):
    while low <= high :
        mid = (low + high) // 2 
        cnt, tempSum = 0, 0
        # 하나씩 담아보면서 mid보다 큰 지 안 큰지 확인해보고
        # 크다면 블루레이 갯수를 추가시켜준다.
        for i in range(N):
            if tempSum + video[i] > mid :
                tempSum = 0
                cnt += 1
            tempSum += video[i]

        # for문을 다 돌고나서 마지막 tempSum이 0이 아닌경우는
        # 가정한 mid값보다 작기때문에 블루레이 갯수가 추가가 안된것이므로
        # 하나를 추가해준다.
        if tempSum != 0 : cnt += 1

        # 블루레이의 개수가 M과 비교하여 high와 low 값을 변경
        if cnt <= M:
            high = mid - 1
        else:
            low = mid + 1
    return low

N, M = map(int,input().split())
video = list(map(int,input().split()))
low, high = max(video), sum(video)
print(binarySearch(low, high))
```

### 메모리 및 수행 속도

메모리 : 40000 KB <br>

시간 : 516 ms <br>

## c++ code

```c++
// 백준 2343 기타레슨
// cpp solved by binary search
#include<iostream>
#define MAX(a,b) {a > b ? a : b}

int main(void){
    int N, M;
    long long video[100001];
    // low => biggest element in video arr
    // high => sum of all elements in video arr
    long long low = -1, high = 0;
    scanf("%d %d", &N, &M);
    for(int i = 0; i < N; i++){
        scanf("%lld", &video[i]);
        low = MAX(low, video[i]);
        high += video[i];
    }

    while(low <= high){
        // mid is predict value 
        long long mid = (low + high) / 2;
        long long tempSum = 0, cnt = 0;
        for(int i = 0; i < N; i++){
            if(tempSum + video[i] > mid){
                tempSum = 0;
                cnt ++;
            }
            tempSum += video[i];
        }
        if(tempSum != 0) cnt++;
        if(cnt <= M){
            high = mid - 1;
        }else{
            low = mid + 1;
        }
    }
    printf("%lld", low);
    return 0;
}
```

### 메모리 및 수행 속도

메모리 : 2648 KB <br>

시간 : 16 ms<br>



## 3020 개똥벌레 

[문제로 이동](https://www.acmicpc.net/problem/3020)

### 접근 방법 

#### Python

``` python
for i in range(1, N+1):
    n = int(sys.stdin.readline())
    if i % 2 == 0:
        for j in range(1,n+1):
             fromUp[j] += 1
    else:
        for j in range(1,n+1):
          fromDown[j] += 1

_sum[1] = fromDown[1]
_sum[H] = fromUp[1]
for i in range(2, H):
    _sum[i] = fromUp[i] + fromDown[H + 1 -i]
```



처음에는 석순과 종유석의 높이를 따로 리스트로 입력받아서 해당 높이만큼 부셔야하는 벽을 하나씩 카운트 해주었다. 

그러나 n<sup>2</sup> 의 시간복잡도로 작성한 코드여서 시간초과가 발생하였고 그래서 다른 방법을 사용하였다.

로직 자체는 비슷하지만 입력받을 때 해당 높이만 카운트 해주었고 i 번째 부셔야하는 벽의 개수를 더해가는 부분을 따로 구분하여 작성해주었다. 



#### C++

python과 같은 로직으로 풀었다.



## python code

```python
import sys
N, H = map(int,sys.stdin.readline().split())
fromUp = [0 for _ in range(H+1)] #even
fromDown = [0 for _ in range(H+1)] #odd
_sum = [500001]+[0 for _ in range(H)]

for i in range(1, N+1):
    n = int(sys.stdin.readline())
    if i % 2 == 0:
        fromUp[n] += 1
    else:
        fromDown[H - n + 1] += 1

# 아래에서부터 자라는 석순은 큰 숫자보다 아래 숫자일수록 부셔야하는 벽이 많음
# 따라서 i 번째 일때 i+1번째 것까지 더해야함
for i in range(H - 1, 0, -1):
    fromUp[i] += fromUp[i+1]
# 위에서부터 자라는 종유석의 높이를 H - n + 1 로 계산했기 때문에
# 작은 높이일수록 부셔야하는 벽이 적고 큰 숫자일 수록 부셔야하는 벽이 많음
# 따라서 i 번째일 때 i-1번째 벽의 개수를 더해주어야함
for i in range(2, H + 1):
    fromDown[i] += fromDown[i-1]

for i in range(1, H + 1):
    _sum[i] = fromUp[i] + fromDown[i]

ans = min(_sum)
print(ans,_sum.count(ans))
```

### 메모리 및 수행 속도

메모리 : 88004 KB <br>

시간 : 612 ms <br>



## c++ code

```c++

```

### 메모리 및 수행 속도

메모리 : 17704 KB <br>

시간 : 336 ms<br>



## 10844 쉬운 계단수

[문제로 이동](https://www.acmicpc.net/problem/10844)

### 접근 방법 

#### Python

처음에 이 문제를 접근 할 때는 1-9까지의 숫자중 가장 큰 자리수를 기준으로해서 -1, +1 한 숫자들만 가능하므로 N자리 수일 때, <br>



#### C++

python과 같은 로직이지만 공간복잡도에서 훨씬 절약할 수 있는 방법을 찾아내었다.  <br>



## python code

```python

```

### 메모리 및 수행 속도

메모리 : 29380 KB <br>

시간 : 72 ms <br>



## c++ code

```c++

```

### 메모리 및 수행 속도

메모리 : 1984 KB <br>

시간 : 0 ms<br>



---

### 참조

[개발 일기's 2098 외판원 순회](https://developmentdiary.tistory.com/406) <br>

[코딩 못하는 사람's 2098 외판원 순회](https://cantcoding.tistory.com/1)<br>

[10844 쉬운 계단수 슬라이딩 윈도우 기법](https://sihyungyou.github.io/baekjoon-10844/) <br> 

